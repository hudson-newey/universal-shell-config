package build

import (
	"fmt"
	"os/exec"
	"strings"
	"usc/config"
)

func buildWarnings(filePath string) {
	warnings := "# DO NOT EDIT. Configuration generated by usc\n"
	appendToFile(filePath, warnings)
}

func BuildTemplates(configuration *config.Config, outDir string, shouldInstall bool) {
	var derivedBuildConfigs []BuildConfig

	for _, buildConfig := range defaultBuildConfigs {
		derivedBuildConfig := buildConfig
		derivedBuildConfig.OutFile = "./" + outDir + "/" + derivedBuildConfig.OutFile
		derivedBuildConfigs = append(derivedBuildConfigs, derivedBuildConfig)
	}

	if !directoryExists(outDir) {
		createDirectory(outDir)
	}

	for _, bc := range derivedBuildConfigs {
		if fileExists(bc.OutFile) {
			deleteFile(bc.OutFile)
		}

		buildWarnings(bc.OutFile)
	}

	fmt.Println()
	for _, buildConfig := range derivedBuildConfigs {
		fmt.Println("Building", buildConfig.OutFile)

		for _, target := range configuration.Aliases {
			if OutputSatisfiesTarget(buildConfig.OutFile, target.Files) {
				for _, alias := range target.Items {
					aliasTemplate := buildConfig.AliasConverter(alias)
					appendToFile(buildConfig.OutFile, aliasTemplate)
				}
			}
		}

		for _, target := range configuration.Sources {
			if OutputSatisfiesTarget(buildConfig.OutFile, target.Files) {
				for _, source := range target.Items {
					sourceTemplate := buildConfig.SourceConverter(source)
					appendToFile(buildConfig.OutFile, sourceTemplate)
				}
			}
		}

		for _, target := range configuration.Paths {
			if OutputSatisfiesTarget(buildConfig.OutFile, target.Files) {
				for _, path := range target.Items {
					pathTemplate := buildConfig.PathConverter(path)
					appendToFile(buildConfig.OutFile, pathTemplate)
				}
			}
		}

		// pre-interaction commands should always come last because they sometimes depend on
		// aliases, sources, and paths
		for _, target := range configuration.Commands {
			if OutputSatisfiesTarget(buildConfig.OutFile, target.Files) {
				for _, command := range target.Items {
					commandTemplate := buildConfig.CommandConverter(command)
					appendToFile(buildConfig.OutFile, commandTemplate)
				}
			}
		}
	}

	if shouldInstall {
		fmt.Println()
		for _, buildConfig := range derivedBuildConfigs {
			InstallBuild(buildConfig)
		}
	}

	fmt.Println("\nDone!")
}

// TODO: split this into a septate package
func InstallBuild(config BuildConfig) {
	installationPath := config.InstallPath

	fmt.Println("Installing", installationPath)

	// TODO: I've hard coded the install path because I have to call $PROFILE inside a powershell session
	// this is obviously not ideal. maybe a set of install scripts for every build config?
	if installationPath == "Profile.ps1" {
		out, err := exec.Command("./paths/profilePath.ps1").Output()
		if err != nil {
			panic(err)
		}

		installationPath = strings.TrimSuffix(string(out), "\n")
	} else {
		out, err := exec.Command("./paths/profilePath.sh").Output()
		if err != nil {
			panic(err)
		}

		installationPath = strings.TrimSuffix(string(out), "\n") + "/" + config.InstallPath
	}

	if fileExists(installationPath) {
		deleteFile(installationPath)
	}

	copyFile(config.OutFile, installationPath)
}
